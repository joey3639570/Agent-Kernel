"""Multi-modal message schema definitions.

This module provides the core Message and MessageContent types that support
text, images, audio, and arbitrary metadata for multi-modal agent communication.
"""

from __future__ import annotations

from dataclasses import asdict, dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field


class MessageKind(str, Enum):
    """Enumerate the origin and destination classes for a message.

    Attributes:
        FROM_AGENT_TO_AGENT: Message sent from one agent to another agent.
        FROM_AGENT_TO_USER: Message sent from an agent to a user.
        FROM_USER_TO_AGENT: Message sent from a user to an agent.
        FROM_SYSTEM: Message generated by the system (e.g., environment events).
    """

    FROM_AGENT_TO_AGENT = "from_agent_to_agent"
    FROM_AGENT_TO_USER = "from_agent_to_user"
    FROM_USER_TO_AGENT = "from_user_to_agent"
    FROM_SYSTEM = "from_system"


class MessageContent(BaseModel):
    """Multi-modal content container for messages.

    This schema supports text, images, audio, and arbitrary metadata,
    enabling rich multi-modal communication between agents.

    Attributes:
        text: The textual content of the message. Can be None for non-text messages.
        images: List of image references (base64 encoded strings or URLs).
        audio: Optional audio reference (file path or URL).
        metadata: Additional key-value metadata for extensibility.
    """

    text: Optional[str] = None
    images: List[str] = Field(default_factory=list)
    audio: Optional[str] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)

    def has_images(self) -> bool:
        """Check if the message contains any images."""
        return len(self.images) > 0

    def has_audio(self) -> bool:
        """Check if the message contains audio."""
        return self.audio is not None

    def is_multimodal(self) -> bool:
        """Check if the message contains non-text content."""
        return self.has_images() or self.has_audio()

    @classmethod
    def from_text(cls, text: str, **metadata: Any) -> "MessageContent":
        """Create a text-only message content."""
        return cls(text=text, metadata=metadata)

    @classmethod
    def from_image(cls, image: str, caption: Optional[str] = None, **metadata: Any) -> "MessageContent":
        """Create an image message content with optional caption."""
        return cls(text=caption, images=[image], metadata=metadata)

    def to_legacy_content(self) -> Any:
        """Convert to legacy content format for backward compatibility.

        If the message is text-only, returns the text string directly.
        Otherwise returns a dict representation.
        """
        if not self.is_multimodal() and not self.metadata:
            return self.text
        return self.model_dump(exclude_none=True, exclude_defaults=True)


@dataclass
class Message:
    """Serializable structure representing a message passed within the system.

    This class maintains backward compatibility with the original Message schema
    while supporting the new MessageContent type for multi-modal content.

    Attributes:
        from_id: Identifier of the sender.
        to_id: Identifier of the recipient (can be a list for broadcast).
        kind: The kind of message being sent.
        content: The main content of the message (str, dict, or MessageContent).
        conversation_id: Optional identifier for the conversation thread.
        created_at: Timestamp when the message was created.
        extra: Additional metadata for the message.
    """

    from_id: str
    to_id: Union[str, List[str]]
    kind: MessageKind
    content: Union[str, Dict[str, Any], MessageContent, Any]
    conversation_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    extra: Optional[Dict[str, Any]] = None

    def get_content_as_multimodal(self) -> MessageContent:
        """Get content as MessageContent, converting if necessary.

        Returns:
            MessageContent instance representing the message content.
        """
        if isinstance(self.content, MessageContent):
            return self.content
        elif isinstance(self.content, str):
            return MessageContent(text=self.content)
        elif isinstance(self.content, dict):
            # Try to parse as MessageContent
            try:
                return MessageContent(**self.content)
            except Exception:
                # Fallback: treat as text with metadata
                return MessageContent(text=str(self.content), metadata=self.content)
        else:
            return MessageContent(text=str(self.content))

    def get_text_content(self) -> Optional[str]:
        """Extract text content from the message.

        Returns:
            The text content if available, None otherwise.
        """
        mc = self.get_content_as_multimodal()
        return mc.text

    def is_multimodal(self) -> bool:
        """Check if this message contains multi-modal content."""
        mc = self.get_content_as_multimodal()
        return mc.is_multimodal()

    def to_dict(self) -> Dict[str, Any]:
        """Convert the message into a dictionary suitable for serialisation.

        Returns:
            Dict[str, Any]: Dataclass fields serialised as a dictionary.
        """
        d = asdict(self)
        # Handle MessageContent serialization
        if isinstance(self.content, MessageContent):
            d["content"] = self.content.model_dump()
        return d

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Message":
        """Create a Message from a dictionary.

        Args:
            data: Dictionary containing message fields.

        Returns:
            Message instance.
        """
        # Handle MessageKind conversion
        if isinstance(data.get("kind"), str):
            data["kind"] = MessageKind(data["kind"])

        # Handle datetime conversion
        if isinstance(data.get("created_at"), str):
            data["created_at"] = datetime.fromisoformat(data["created_at"])

        return cls(**data)

