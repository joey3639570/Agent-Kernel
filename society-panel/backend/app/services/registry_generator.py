"""
Service for scanning workspace and generating registry.py file.
"""

import os
import ast
import yaml
import textwrap
from typing import Dict, List, Set, Tuple


class RegistryGenerator:
    """
    A service class that scans Python files and configuration files in the workspace,
    analyzes class definitions and configuration items, and automatically generates
    a registry.py file that registers all user-defined plugins and framework core modules.
    """

    def __init__(self):
        """
        Initialize the RegistryGenerator with base class mappings and known framework classes.
        """
        self.BASE_CLASS_MAP = {
            "ProfilePlugin": ("agent_plugins", "profile"),
            "StatePlugin": ("agent_plugins", "state"),
            "PlanPlugin": ("agent_plugins", "plan"),
            "InvokePlugin": ("agent_plugins", "invoke"),
            "PerceivePlugin": ("agent_plugins", "perceive"),
            "ReflectPlugin": ("agent_plugins", "reflect"),
            "CommunicationPlugin": ("action_plugins", "communication"),
            "FunctionToolPlugin": ("action_plugins", "tools"),
            "OtherActionsPlugin": ("action_plugins", "otheractions"),
            "MCPToolPlugin": ("action_plugins", "tools"),
            "RelationPlugin": ("environment_plugins", "relation"),
            "SpacePlugin": ("environment_plugins", "space"),
            "ControllerImpl": ("controller", None),
            "PodManagerImpl": ("pod_manager", None),
        }

        self.KNOWN_FRAMEWORK_CLASSES = {
            "RedisKVAdapter": "agentkernel_distributed.toolkit.storages",
            "RedisGraphAdapter": "agentkernel_distributed.toolkit.storages",
            "MilvusVectorAdapter": "agentkernel_distributed.toolkit.storages",
            "PostgresAdapter": "agentkernel_distributed.toolkit.storages",
            "OpenAIProvider": "agentkernel_distributed.toolkit.models.api",
            "ControllerImpl": "agentkernel_distributed.mas.controller",
            "PodManagerImpl": "agentkernel_distributed.mas.pod",
        }

        self.STATIC_IMPORTS = """
# --- Framework Core Components ---
from agentkernel_distributed.mas.agent.components import (
    ProfileComponent, StateComponent, PlanComponent, PerceiveComponent, ReflectComponent, InvokeComponent
)
from agentkernel_distributed.mas.action.components import (
    CommunicationComponent, ToolsComponent, OtherActionsComponent
)
from agentkernel_distributed.mas.environment.components import (
    RelationComponent, SpaceComponent
)
from agentkernel_distributed.mas.system.components import Messager, Recorder, Timer
"""

        self.REGISTRY_TEMPLATE = """# This file is auto-generated by the SOCIETY-PANEL backend. Do not edit manually.

{static_imports}

# --- Dynamically Imported User Plugins and Framework Modules ---
{dynamic_imports}

# =============================================================================
# --- Resource Mapping Dictionaries ---
# =============================================================================

# --- Agent Plugins and Components Mapping ---
agent_plugin_class_map = {{
{agent_plugins}
}}
agent_component_class_map = {{
{agent_components}
}}

# --- Action Plugins and Components Mapping ---
action_plugin_class_map = {{
{action_plugins}
}}
action_component_class_map = {{
{action_components}
}}

# --- Environment Plugins and Components Mapping ---
environment_plugin_class_map = {{
{environment_plugins}
}}
environment_component_class_map = {{
{environment_components}
}}

# --- System Components Mapping ---
system_component_class_map = {{
    "messager": Messager,
    "recorder": Recorder,
    "timer": Timer,
}}

# --- Adapter Mapping ---
adapter_class_map = {{
{adapter_map_entries}
}}

# --- Model Mapping ---
model_class_map = {{
{model_map_entries}
}}

# --- Aggregate All Mappings ---
RESOURCE_MAPS = {{
    "agent_components": agent_component_class_map,
    "agent_plugins": agent_plugin_class_map,
    "action_components": action_component_class_map,
    "action_plugins": action_plugin_class_map,
    "environment_components": environment_component_class_map,
    "environment_plugins": environment_plugin_class_map,
    "system_components": system_component_class_map,
    "adapters": adapter_class_map,
    "models": model_class_map,
    "controller": {controller},
    "pod_manager": {pod_manager},
}}
"""

    def _parse_file_for_classes(self, file_path: str) -> List[Tuple[str, List[str]]]:
        """
        Parse a Python file and extract class definitions with their base classes.

        Args:
            file_path (str): The path to the Python file to parse.

        Returns:
            List[Tuple[str, List[str]]]: A list of tuples containing class names and their base class names.
        """
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()
            tree = ast.parse(content)
            classes = []
            for node in ast.walk(tree):
                if isinstance(node, ast.ClassDef):
                    if node.name.startswith("_"):
                        continue
                    base_names = [b.id for b in node.bases if isinstance(b, ast.Name)]
                    classes.append((node.name, base_names))
            return classes
        except Exception as e:
            print(f"Warning: Could not parse {file_path}. Error: {e}")
            return []

    async def get_registry_info(self, workspace_path: str) -> Dict[str, any]:
        """
        Scan the workspace and collect information about available plugins.

        Args:
            workspace_path (str): The path to the workspace directory.

        Returns:
            Dict[str, any]: A dictionary containing plugin information organized by category.
        """
        registry_info = {
            "agent_plugins": {"profile": [], "state": [], "plan": [], "invoke": [], "perceive": [], "reflect": []},
            "action_plugins": {"communication": [], "tools": [], "otheractions": []},
            "environment_plugins": {"relation": [], "space": []},
            "controller": None,
            "pod_manager": None,
        }
        for root, _, files in os.walk(workspace_path):
            if ".venv" in root or "__pycache__" in root:
                continue
            for file in files:
                if not file.endswith(".py") or file == "registry.py":
                    continue

                file_path = os.path.join(root, file)
                found_classes = self._parse_file_for_classes(file_path)
                for class_name, base_classes in found_classes:
                    for base_name in base_classes:
                        if base_name in self.BASE_CLASS_MAP:
                            category, sub_category = self.BASE_CLASS_MAP[base_name]
                            if sub_category:
                                if class_name not in registry_info[category][sub_category]:
                                    registry_info[category][sub_category].append(class_name)
                            else:
                                registry_info[category] = class_name
                            break
        return registry_info

    async def generate_registry_file(self, workspace_path: str):
        """
        Generate the registry.py file by scanning the workspace.

        Args:
            workspace_path (str): The path to the workspace directory.

        Raises:
            RuntimeError: If there is an error processing configuration files.
        """
        print("Starting to generate registry.py...")

        user_modules = {}
        plugin_mappings = {"agent_plugins": [], "action_plugins": [], "environment_plugins": []}
        controller_class = "ControllerImpl"
        pod_manager_class = "PodManagerImpl"

        for root, _, files in os.walk(workspace_path):
            if ".venv" in root or "__pycache__" in root:
                continue
            for file in files:
                if not file.endswith(".py") or file == "registry.py":
                    continue

                file_path = os.path.join(root, file)
                module_path = os.path.relpath(file_path, workspace_path).replace(os.sep, ".")[:-3]

                found_classes = self._parse_file_for_classes(file_path)

                for class_name, base_classes in found_classes:
                    user_modules[class_name] = module_path
                    for base_name in base_classes:
                        if base_name in self.BASE_CLASS_MAP:
                            category, _ = self.BASE_CLASS_MAP[base_name]
                            if category in plugin_mappings:
                                plugin_mappings[category].append(f'    "{class_name}": {class_name},')
                            elif category == "controller":
                                controller_class = class_name
                            elif category == "pod_manager":
                                pod_manager_class = class_name
                            break

        configs_dir = os.path.join(workspace_path, "configs")
        dynamic_imports = set()
        adapter_map_entries = []
        model_map_entries = []

        try:
            db_config_path = os.path.join(configs_dir, "db_config.yaml")
            if os.path.exists(db_config_path):
                with open(db_config_path, "r", encoding="utf-8") as f:
                    db_config = yaml.safe_load(f)
                if db_config and "adapters" in db_config:
                    for key, adapter_conf in db_config["adapters"].items():
                        class_name = adapter_conf.get("class_name")
                        if not class_name:
                            raise ValueError(f"Adapter '{key}' in db_config.yaml is missing 'class_name'.")

                        if class_name in self.KNOWN_FRAMEWORK_CLASSES:
                            module_path = self.KNOWN_FRAMEWORK_CLASSES[class_name]
                            dynamic_imports.add(f"from {module_path} import {class_name}")
                        elif class_name in user_modules:
                            dynamic_imports.add(f"from {user_modules[class_name]} import {class_name}")
                        else:
                            raise ValueError(f"Adapter class '{class_name}' for '{key}' not found.")
                        adapter_map_entries.append(f'    "{key}": {class_name},')
        except Exception as e:
            raise RuntimeError(f"Error processing db_config.yaml: {e}")

        try:
            models_config_path = os.path.join(configs_dir, "models_config.yaml")
            if os.path.exists(models_config_path):
                with open(models_config_path, "r", encoding="utf-8") as f:
                    models_config = yaml.safe_load(f)
                if models_config:
                    for model_conf in models_config:
                        class_name = model_conf.get("name")
                        if not class_name:
                            raise ValueError("An entry in models_config.yaml is missing 'name'.")

                        if class_name in self.KNOWN_FRAMEWORK_CLASSES:
                            module_path = self.KNOWN_FRAMEWORK_CLASSES[class_name]
                            dynamic_imports.add(f"from {module_path} import {class_name}")
                        elif class_name in user_modules:
                            dynamic_imports.add(f"from {user_modules[class_name]} import {class_name}")
                        else:
                            raise ValueError(f"Model class '{class_name}' not found.")
                        model_map_entries.append(f'    "{class_name}": {class_name},')
        except Exception as e:
            raise RuntimeError(f"Error processing models_config.yaml: {e}")

        for class_name, module_path in user_modules.items():
            dynamic_imports.add(f"from {module_path} import {class_name}")

        if controller_class not in user_modules:
            dynamic_imports.add(f"from {self.KNOWN_FRAMEWORK_CLASSES['ControllerImpl']} import ControllerImpl")
        if pod_manager_class not in user_modules:
            dynamic_imports.add(f"from {self.KNOWN_FRAMEWORK_CLASSES['PodManagerImpl']} import PodManagerImpl")

        agent_components_str = """
    "profile": ProfileComponent,
    "state": StateComponent,
    "plan": PlanComponent,
    "perceive": PerceiveComponent,
    "reflect": ReflectComponent,
    "invoke": InvokeComponent,"""
        action_components_str = """
    "communication": CommunicationComponent,
    "tools": ToolsComponent,
    "otheractions": OtherActionsComponent,"""
        environment_components_str = """
    "relation": RelationComponent,
    "space": SpaceComponent,"""

        registry_content = self.REGISTRY_TEMPLATE.format(
            static_imports=self.STATIC_IMPORTS.strip(),
            dynamic_imports="\n".join(sorted(list(dynamic_imports))),
            agent_plugins="\n".join(sorted(plugin_mappings["agent_plugins"])),
            agent_components=textwrap.dedent(agent_components_str).strip(),
            action_plugins="\n".join(sorted(plugin_mappings["action_plugins"])),
            action_components=textwrap.dedent(action_components_str).strip(),
            environment_plugins="\n".join(sorted(plugin_mappings["environment_plugins"])),
            environment_components=textwrap.dedent(environment_components_str).strip(),
            adapter_map_entries="\n".join(sorted(adapter_map_entries)),
            model_map_entries="\n".join(sorted(list(set(model_map_entries)))),
            controller=controller_class,
            pod_manager=pod_manager_class,
        )

        registry_file_path = os.path.join(workspace_path, "registry.py")
        with open(registry_file_path, "w", encoding="utf-8") as f:
            f.write(registry_content)
        print(f"Successfully regenerated registry.py at: {registry_file_path}")


registry_generator = RegistryGenerator()
